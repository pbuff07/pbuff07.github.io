---
title: "TCP协议基础"
date: 2022-05-14T14:00:00+08:00
categories: ["协议分析"]
tags: ["tcp", "网络协议"]
toc: false
numberedSubtitles: false
---



**tcp协议基本连接**

三次握手和四次挥手

我通过执行`curl http://74.121.150.28`捕获的WireShark数据来分析tcp协议的基本连接过程，如下图所示：

![image-20251117234728404](https://pbuff-blogs-1257793641.cos.ap-chengdu.myqcloud.com//blogsimage-20251117234728404.png)

59（客户端IP别称）想7428（服务端IP别称）的三次握手如上图所示，59发送SYN数据包到7428，服务端7428收到之后响应SYN+ACK数据包，然后客户端回复ACK数据包以表示收到服务端的响应。

------------------

Seq（序列号）：TCP是有序的，当数据包延迟或者提前到达了服务端在无序的状态下也可以根据Seq号进行排序，进而判断出是否丢包、是否乱序等问题。TCP是双向的所以客户端和服务端各维护了一个Seq号。

Seq的增长方式是Seq = Seq + Len（数据段长度），特别注意："TCP SYN 和 FIN 即便没有数据，也会消耗 1 个序列号"

如上图所示，27号包Seq=0，Len=0，由客户端维护的31号包Seq=1，Len=0（因为SYN包会消耗一个序列号，这是标准行为中确定的）

![image-20251117234720113](https://pbuff-blogs-1257793641.cos.ap-chengdu.myqcloud.com//blogsimage-20251117234720113.png)

我将用上图客户端侧（59）维护的Seq来说明下具体Seq号增长的过程：

1、初始SYN数据包，Seq=0，因为SYN和FIN即便Len=0没有数据也会消耗一个Seq

2、所以31号包的Seq=1，Len=0

3、32号包因为HTTP协议发送了Len=76的数据，Seq=1

4、46号包的Seq=76+1=77，此时Len=0

5、47号包的Seq = 77 + Len（0），因为47号包发送的FIN+ACK包，上述说了FIN包也会消耗一个Seq，所以Seq=77+1=78，此时Len=0

6、56号包是ACK响应包，Seq = 78 + Len（0） = 78

基于上述的过程，有服务端维护的Seq号也是同样的增长逻辑。分析Seq的需要注意SYN/FIN也会消耗一个Seq

------------------

Ack（确认号）：








**nmap的-sS参数扫描**

-sS 使用TCP SYN扫描目标

-sS参数扫描的显著特点是短时间内向目标IP的指定端口（默认是全部）发送大量的SYN探测数据包。

如果服务端响应SYN+ACK数据包则说明该端口开放，客户端立即发送RST+ACK数据包断开连接；如果服务端不响应SYN+ACK数据包则说明端口未开放

![image-20251117234647633](https://pbuff-blogs-1257793641.cos.ap-chengdu.myqcloud.com//blogsimage-20251117234647633.png)

**nmap的-sT参数扫描**

-sT使用TCP完整连接扫描目标

sT参数是全连接，也就是会包含SYN、SYN+ACK、ACK响应三次握手的全过程。如果三次握手成功，则端口开放，客户端在三次握手之后直接发送RST+ACK数据包终止连接；如果三次握手失败则端口不开放。

如下图所示，建立连接的过程就是标准的三次握手过程，不同的是没有四次挥手（双向的FIN+ACK和ACK确认），而是在服务端响应之后直接RST+ACK数据包关闭连接。

![image-20251118214927798](https://pbuff-blogs-1257793641.cos.ap-chengdu.myqcloud.com//blogsimage-20251118214927798.png)

**nmap的-sF参数扫描**

-sF只发送FIN数据包进行探测，如果端口开放则没有任何响应，如果端口关闭则服务端会响应RST数据包，这个和-sS和-sT判断结果方式不太一样，是反着来的。

**nmap的sW参数扫描**

87.182.115.208
